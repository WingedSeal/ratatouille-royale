from setuptools import Extension
from Cython.Build import cythonize
from pathlib import Path
import os
import shutil

# No contextlib needed anymore
# NEW IMPORTS required to run build_ext command manually
from setuptools.dist import Distribution
from setuptools.command.build_ext import build_ext

# --- Configuration ---
SOURCE_DIR = "src"
TEMP_BUILD_DIR = "temp_cython_build"  # New temporary directory for compilation output
# --- End Configuration ---


def clean_build_artifacts():
    """Removes previous compiled files (.c, .so, .pyd) from the source tree and build folder."""
    print("--- Cleaning old artifacts ---")

    # 1. Clean source tree artifacts
    for root, dirs, files in os.walk(SOURCE_DIR):
        for name in files:
            # Delete compiled C/C++ files generated by Cython
            if name.endswith(".c") or name.endswith(".cpp"):
                os.remove(os.path.join(root, name))
            # Delete compiled binary modules (.so, .pyd, .dll)
            elif name.endswith((".so", ".pyd", ".dll")):
                # Only clean files that are NOT in a temporary build directory if the OS walk somehow includes it
                if TEMP_BUILD_DIR not in root:
                    os.remove(os.path.join(root, name))

    # 2. Clean temporary build directory
    if os.path.exists(TEMP_BUILD_DIR):
        shutil.rmtree(TEMP_BUILD_DIR)

    print("Clean complete.")


def compile_cython_files():
    """Locates and compiles all .pyx files into Python extension modules."""

    clean_build_artifacts()

    # Find all .pyx files recursively under the source directory, excluding files starting with '_'
    pyx_files = [
        f for f in Path(SOURCE_DIR).rglob("*.pyx") if not f.name.startswith("_")
    ]

    if not pyx_files:
        print("No .pyx files found to compile.")
        return

    print(f"\n--- Found {len(pyx_files)} .pyx files to compile ---")

    extensions = []

    # NEW LOGIC: Collect all module paths for later manual copying
    module_paths = {}

    for pyx_file in pyx_files:
        # Calculate the module name: src/ratroyale/foo.pyx -> ratroyale.foo
        module_name = str(pyx_file.relative_to(SOURCE_DIR).with_suffix("")).replace(
            os.sep, "."
        )

        # Store the target directory for the final binary copy
        module_paths[module_name] = pyx_file.parent

        # Create Extension object
        extensions.append(
            Extension(
                module_name,
                [str(pyx_file)],
                # Note: The C compiler (cl on Windows) ignores -O3, so this is just a warning.
                extra_compile_args=["-O3"],
            )
        )
        print(f"  > Processing: {module_name} ({pyx_file})")

    # 1. Run cythonize: This converts .pyx files to .c files and updates extension metadata.
    cythonized_extensions = cythonize(
        extensions,
        compiler_directives={"language_level": "3"},
    )

    # 2. Set up a dummy distribution object required by the build_ext command
    dist = Distribution({"ext_modules": cythonized_extensions})

    # 3. Instantiate and configure the build_ext command
    cmd = build_ext(dist)

    # CRITICAL CHANGE: Use a temporary folder for compilation output,
    # instead of the buggy inplace=1. Note: This path is relative to the project root.
    cmd.build_lib = TEMP_BUILD_DIR

    # 4. Run the build command to compile the modules into the temporary folder
    print(f"\n--- Running Build Command (Outputting to: {TEMP_BUILD_DIR}) ---")
    cmd.ensure_finalized()
    cmd.run()

    # 5. Manually copy the compiled binaries back into the source tree
    print("\n--- Copying compiled binaries to source directories ---")
    for module_name, target_dir in module_paths.items():
        # The build output path is based on the module name (e.g., TEMP_BUILD_DIR/ratroyale/backend/)

        # Calculate the path inside the temporary build directory:
        # TEMP_BUILD_DIR + [ratroyale/backend] (The package structure relative to the CWD)
        # Note: Setuptools creates the package structure inside the build folder.

        search_path = (
            Path(TEMP_BUILD_DIR) / Path(module_name.replace(".", os.sep)).parent
        )

        copied_success = False

        # Ensure the directory exists before listing its contents
        if os.path.isdir(search_path):
            for f in os.listdir(search_path):
                # Look for the compiled file extension (.so, .pyd)
                # f.startswith(Path(module_name.split('.')[-1]).stem) looks for 'hexagon'
                if f.startswith(Path(module_name.split(".")[-1]).stem) and f.endswith(
                    (".so", ".pyd", ".dll")
                ):
                    source_file = os.path.join(search_path, f)
                    destination_file = os.path.join(target_dir, f)

                    # Ensure target directory exists (though it should from the initial check)
                    os.makedirs(target_dir, exist_ok=True)

                    shutil.copy2(source_file, destination_file)
                    print(f"  > Copied: {f} -> {target_dir}")
                    copied_success = True
                    break

        if not copied_success:
            print(
                f"  > ⚠️ WARNING: Could not find compiled binary for module {module_name} in {search_path}"
            )

    # 6. Clean up the temporary build directory
    if os.path.exists(TEMP_BUILD_DIR):
        shutil.rmtree(TEMP_BUILD_DIR)
        print(f"\n--- Cleaned up temporary directory: {TEMP_BUILD_DIR} ---")

    print("\n✅ Compilation and placement successful.")


if __name__ == "__main__":
    try:
        compile_cython_files()
    except Exception as e:
        print(f"\n❌ ERROR during compilation: {e}")
        print(
            "\nEnsure 'cython' and 'setuptools' are installed in your current environment."
        )
        print("Run `poetry install --with dev` if needed, and try again.")
